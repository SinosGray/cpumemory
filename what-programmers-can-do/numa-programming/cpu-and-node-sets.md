# 6.5.6. CPU 与节点集合

借由将程序改变为使用目前为止所描述的介面来为 SMP 与 NUMA 环境调整程序，在来源[^译注]无法取得的情况下可能会极为昂贵（或者不可能）。此外，系统管理员可能想要对使用者和／或行程能够使用的资源施加限制。对于这些情境，Linux 系统核心支援所谓的 CPU 集。这个名称有一点误导，因为memory节点也被涵盖其中。它们也与 `cpu_set_t` 资料型别无关。

此刻，CPU 集的介面为一个特殊的档案系统。它通常没有被挂载（mount）（至少到目前为止）。这能够使用

`mount -t cpuset none /dev/cpuset`

改变。挂载点 `/dev/cpuset` 在这个时间点当然必须存在。这个目录的内容为预设（根）CPU 集的描述。它起初由所有的 CPU 与所有的memory节点所构成。这个目录中的 `cpus` 档案显示在 CPU 集中的 CPU、`mems` 档案显示memory节点、`tasks` 档案显示行程。

为了建立一个新的 CPU 集，只要在阶层结构中的某个地方建立一个新的目录。新的 CPU 集会继承来自父集合的所有设定。接著，新的 CPU 集的 CPU 与memory节点能够借由将新值写到在新目录中的 `cpus` 与 `mems` 虚拟档案来更改。

若是一个行程属于一个 CPU 集，CPU 与memory节点的设定会被用作亲和性与memory策略bit遮罩的遮罩。这表示，程序无法在亲和性遮罩里选择不在行程正在使用的 CPU 集（即，它在 `tasks` 档案中列出的位置）的 `cpus` 档案中的任何 CPU。对于memory策略的节点遮罩与 `mems` 档案也是类似的。

除非bit遮罩在遮罩后为空，否则程序不会经历任何错误，因此 CPU 集是一种控制程序执行的近乎无形的手段。这种方法在有著大量 CPU 与／或memory节点时是尤其有效率的。将一个行程移到一个新的 CPU 集，就跟将行程 ID 写到合适 CPU 集的 `tasks` 档案一样简单。

CPU 集的目录包含许多其它档案，能用来指定像是memory压力下、以及独占存取 CPU 与memory节点时的行为。感兴趣的读者请参阅系统核心原始码树中的档案 `Documentation/cpusets.txt`。


[^译注]: 根据前后文猜测，这里的「来源」指的应该是程序使用的 CPU 与memory节点。
